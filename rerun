#!/usr/bin/env bash

# USAGE:
#
#   rerun COMMAND
#
# Reruns COMMAND on every filesystem 'modify' event in the current directory.
# Useful for things like running tests whenever you hit 'save' in your editor.
#
# COMMAND is evaluated by Bash before it gets passed to rerun. To prevent
# this you must quote or escape things.
#
# Rerun does not implicitly re-evaluate the command on every iteration,
# it just executes it.
#
# Hence, if a command consists of more than "EXE arg1 arg2 ...", i.e. you
# need Bash to evaluate the command before executing it, e.g. it is a compound
# command featuring ';' or '&&' or '|', then you need to explicitly execute
# your command in a subshell, that will do this evaluation.
# For example, if you would like 'rerun' to execute the COMMAND:
#
#   date ; echo hello
#
# you cannot pass this to 'rerun' directly, because the command needs a shell
# to interpret it on every execution, to take care of the '|', invoking
# separate processes and piping them together. Hence you must:
#
#   rerun sh -c "date ; echo hello"
#
# If you are re-evaluating COMMAND like this on every execution, may use
# $change in your COMMAND, which is set to the name of the modified file on all
# but the first execution. e.g:
#
#   rerun sh -c 'echo $change'
#
# If COMMAND contains shell aliases, source rerun using a preceding dot:
#
#   . rerun COMMAND
#
# TODO: I can't get shell aliases to work. e.g:
#   $ rerun ll
#   ll: Command not found
#   $ . rerun ll
#   ll: Command not found
#
# TODO: Can I avoid running `command` several times on a flurry of
# simultaneous events? I want one call of 'execute' to swallow all the
# events up to that point. Presumably I could put something inside the
# while loop that would skip calling 'execute' if the last call was too
# recent?
# idea: date +'%s.%N'
#
# Test cases:
#
#   rerun ls "some file"
#   Used to fail before removing 'eval'.
#
#   rerun ls some*
#   Used to fail due to spaces in matching filenames,
#   before putting quotes on "$@".
#
#   rerun date
#   Updates the displayed date on every iteration.

function execute() {
    clear
    echo "$@"
    "$@"
}

execute "$@"

inotifywait --quiet --recursive --monitor --event modify --format "%w%f" . \
| while read change; do
    export change
    execute "$@"
done

